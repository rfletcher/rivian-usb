#!/usr/bin/env bash
#
# Summary: Remount filesystems as read-write
#
# Usage: riv util-remount [path...]
#
# Examples:
#   Remount known filesystems as read-write
#     riv util-remount
#   Remount the filesystem containing /foo as read-write
#     riv util-remount /foo

source "${_RIV_SHARE}/riv-stdlib.bash" || exit 1

## Check script dependencies

_require_dependencies findmnt

## Set defaults

DIRS=( / /boot )

## Define functions

function parse_options() {
  if [[ "$#" -gt 0 ]]; then
    DIRS=( "$@" )
  fi
}

function remount() {
  local MOUNTS=()

  _say "Remounting read-only filesystems as read/write..."

  for DIR in "${DIRS[@]}"; do
    MOUNTS+=( "$( _path_to_mount "$DIR" )" )
  done

  # TK does this work for paths/mounts with spaces?
  OLDIFS="$IFS"; 
  IFS=$'\n'
  MOUNTS=( $(printf '%s\n' "${MOUNTS[@]}" | sort | uniq) )
  IFS="$OLDIFS"

  for MOUNT in "${MOUNTS[@]}"; do
    if _is_readonly_mount "$MOUNT"; then
      _say "Remouting as read/write: ${MOUNT}..."
      mount "$MOUNT" -o remount,rw
    else
      _say "Skipping read/write mount: ${MOUNT}"
    fi
  done
}

function validate_input() {
  for DIR in "${DIRS[@]}"; do
    test -d "$DIR" || _die "Path does not exist: $DIR"
  done
}

## Run the script

parse_options "$@" &&
validate_input &&
remount
