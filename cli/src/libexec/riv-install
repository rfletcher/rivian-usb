#!/usr/bin/env bash
#
# Summary: Install/upgrade `riv`
#
# By default `riv` is installed on the local system. Specify -t to install into
# some directory instead (as when building an OS image, for example).
#
# Usage: riv install [opts] [version]
#
# Options:
#   -f Force installation, even if the requested version is already installed.
#   -n Dry run. Don't actually install anything.
#   -s <path|url>: Install from this source repository. If this is a local
#        path, any specified version argument is ignored.
#        Default: https://github.com/rivian-community/rivian-usb
#   -t <path>: Install into a directory, rather than onto the local system
#
# Examples:
#   Install the latest stable version, if it's an upgrade:
#     riv install
#   Install a specific release:
#     riv install 0.0.1

source "${_RIV_SHARE}/riv-stdlib.bash" || exit 1

## Check script dependencies

_require_dependencies curl tar rsync

## Set defaults

DRY_RUN=
FORCE=
PREFIX=/
SOURCE=https://github.com/rivian-community/rivian-usb
VERSION=dev

RIV_DIR=opt/riv
BIN_DIR=usr/local/bin

## Define functions

function parse_options() {
  # parse options
  while getopts ":fs:nt:" opt; do
    case $opt in
      f) FORCE=1;;
      n) DRY_RUN=1;;
      t) PREFIX="$OPTARG";;
      s) SOURCE="$OPTARG";;
      \?) _die "Unknown option (-${OPTARG})";;
    esac
  done

  shift $((OPTIND - 1))

  if [[ "$1" != "" ]]; then
    VERSION="$1"
  fi
}

function install() {
  local CURRENT_VERSION="$(riv version)"
  local TMPDIR=

  function _check_version() {
    if ! _is_url "$SOURCE"; then
      _say "Installing from local source"
    else
      if [[ "$CURRENT_VERSION" == "$VERSION" ]]; then
        _say -n "Version '${VERSION}' is already installed. "
        if [[ "$FORCE" == "1" ]]; then
          echo "Reinstalling..."
        else
          echo
          return
        fi
      else
        _say "Installing version '${VERSION}'..."
      fi
    fi
  }

  function _cleanup() {
    rm -rf "$TMPDIR"

    _say "Done"
  }

  function _fetch() {
    function _fetch_remote() {
      local FILE="${TMPDIR}.tar.gz"
      local URL="${SOURCE}"/archive/"${VERSION}".tar.gz

      _say "Downloading ${URL}..."

      pushd "$TMPDIR" >/dev/null &&
      curl -s -L "$URL" > "$FILE" &&
      tar zxf "$FILE" --strip-components=1 &&
      rm "$FILE" &&
      popd >/dev/null ||
      return 1
    }

    function _fetch_local() {
      _say "Copying from source..."

      rsync -a --delete "${SOURCE}/" "$TMPDIR"/
    }

    if _is_url "$SOURCE"; then
      _fetch_remote
    else
      _fetch_local
    fi
  }

  function _install() {
    if [[ "$DRY_RUN" == "1" ]]; then
      _say "This is a dry run. Not installing."
      return
    fi

    _say "Installing to ${PREFIX%/}/${RIV_DIR}..."

    local SED_BIN=$(which gsed sed | head -1)
    local REL_RIV_BIN=$(echo "$BIN_DIR" | $SED_BIN -re 's/[^/]+/../g')/${RIV_DIR}/bin/riv

    pushd "$PREFIX" >/dev/null &&
    mkdir -p "$RIV_DIR" &&
    mkdir -p "$BIN_DIR" &&
    rsync -a --delete "${TMPDIR}/cli/src"/ "${RIV_DIR}"/ &&
    ln -fs "${REL_RIV_BIN}" "${BIN_DIR}/riv" &&
    popd >/dev/null ||
    return 1
  }

  function _prepare() {
    if ! which findmnt >/dev/null; then
      _say "Skipping read-write remount"
    else
      riv util-remount "${PREFIX##/}/${BIN_DIR}" "${PREFIX##/}${RIV_DIR}" || return 1
    fi

    TMPDIR=$(_tmpdir)
  }

  _check_version &&
  _prepare &&
  _fetch &&
  _install &&
  _cleanup
}

function validate_input() {
  if ! _is_url "$SOURCE" && ! test -d "$SOURCE"; then
    _die "Source (-s) must be either a URL or local repo path"
  fi
}

## Run the script

parse_options "$@" &&
validate_input &&
install
